Μάθημα: Προγραμματισμός Συστήματος
Ονοματεπώνυμο: Κυριάκος Χριστοδούλου
ΑΜ: 1115201300211

Τα παραδοτέα μου δουλεύουν απολύτως σωστά, ικανοποιώντας όλες τις απαιτήσεις της εργασίας.
Η μεταγλώττιση γίνεται με την χρήση του makefile, το οποίο δημιουργεί 2 εκτελέσιμα, το board και το boardpost.
Το board, όπως και το boardpost, παίρνει σαν παράμετρο το directory (πχ /tmp/sdi1100666/myboard1/) και εκεί δημιουργεί τα named pipes που χρειάζονται.
Αποφάσισα να δημιουργώ 2 named pipes για κάθε αμφίδρομη επικοινωνία (ένα για να στέλνει ο server και ένα για να διαβάζει ο server).
Όταν τρέχει το board για πρώτη φορά για κάθε board, δημιουργεί το path, τα fifos και το αρχείο που θα αποθηκεύσει το pid του server και ακολούθως δημιουργήται το server process.
Το server process τρέχει μέχρι να σταλεί signal SIGKILL από τον board μέσω της εντολής shutdown.
Καθώς τρέχει περιμένει να διαβάσει από τα ανάλογα fifos τις ανάλογες εντολές. Όταν λάβει μία εντολή την "σπάζει" σε λέξεις και ελέγχει για την ορθότητα τους.
Το board και το boardpost όταν λάβουν μια εντολή την "σπάζουν" σε λέξεις για να ελέγξουν τα ορίσματα των εντολών τους (πόσα ήρθαν και τον τύπο τους),
αλλά την στέλνουν ολόκληρη στο server για να την διαχειριστεί και ο ίδος.
Για την εντολή list, ο boardpost την στέλνει στο server μέσω του named pipe και περιμένει να διαβάσει την απάντηση, η οποία είναι ένα char* που περιέχει
τα ονόματα των καναλιών του server με τα ID τους. Για την εντολή write, απλά την στέλνει ολόκληρη όπως ήρθε από το stdin και ο server αναλαμβάνει να
ελέγξει αν το ID που δώθηκε υπάρχει. Αν ναι, τότε εισάγει στη λίστα το μήνυμα. Στην περίπτωση που έφτασε η εντολή send, πρώτα θα σταλεί ολόκληρη η
εντολή για να "μάθει" ο server το όνομα του αρχείου και το κανάλι στο οποίο θα το αποθηκεύσει και ακολούθως θα σταλεί ολόκληρο το αρχείο μέσω του fifo
στον server ο οποίος θα δημιουργήσει ένα προσωρινό του αντίγραφο στο path που βρίσκονται τα fifos.
Οι εντολές write και send ΠΡΕΠΕΙ να δωθούν στην μορφή write,<channel_ID>,<TEXT> αντί του απαιτούμενου write <channel_ID> <TEXT> λόγω του ότι η συνάρτηση
που χρησιμοποιώ για "σπάσιμο" της εντολής δεν θα επέτρεπε να σταλούν μηνύματα με κενό.
Η εντολή createchannel του board, αφού ελέγξει τον αριθμό των ορισμάτων και το αν το δεύτερο είναι αριθμός, θα σταλέι στο server για να δημιουργήσει
νέο κανάλι στη λίστα. Τα κανάλια είναι οργανωμένα σε μία δομή λίστας με τους κόμβους της λίστας (κάθε κανάλι είναι ένας κόμβος) να αποτελούνται από τη λίστα μηνυμάτων
και τη λίστα αρχείων για το κάθε κανάλι.
Η εντολή getmessages στέλνει στον server την εντολή και ακολύθως περιμένει από αυτόν να στείλει πίσω τα μηνύματα και τα αρχεία του κατάλληλου καναλιού.
Εάν έρθει "msg" απλά λαμβάνει το μήνυμα και ξαναδιαβάζει από το fifo εάν υπάρχει κάτι άλλο. Όταν σταλούν όλα τα μηνύματα του καναλιού, διαφράφονται
από τη λίστα. Εάν έρθει όμως "receive", τότε πρώτα διαβάζει το όνομα του αρχείου και ακολούθως διαβάζει το περιέχομενό του το οποίο και αποθηκεύει στο
directory που βρίσκεται το executable board. Ο server όταν στείλει το αρχείο τότε διαγράφει το προσωρινό του αντίγραφο και όταν στείλει όλα του τα
αρχεία αδειάζει και τη λίστα με τα αρχεία.
Η απλή εντολή exit, η οποία είναι ακριβώς η ίδια και στο board και στο boardbpost, κλείνει τα fifos που άνοιξε στο εκάστοτε process και τότε απλά
τερματίζει την διεργασία.
Η εντολή shutdown του board αρχικά στέλνει το signal SIGKILL στην server process και ακολούθως κλείνει τα fifos από την πλεύρα του board. Μετά διγράφει όλα
τα αρχεία που βρίσκονται στο φάκελο που δημιούργησε και ακολούθως διαγράφει και το φάκελο.
Όσο αφορά το boardstatus.sh, αυτό που κάνει είναι να ελέγχει κατά πόσο υπάρχουν τα fifo που πρέπει για κάθε φάκελο μέσα στο directory που δώθηκε σαν όρισμα
και στο τέλος αν το process id που βρίσκεται μέσα στο αρχείο pid αντιστοιχεί σε κάποιο active server process. Αν όλα αυτά ισχύουν, τότε έχουμε να κάνουμε με ένα
active board, ενώ στην περίπτωση που δεν υπάρχει το ενεργό server process, έχουμε να κάνουμε με inactive board.

Σημείωση: Για την οργάνωση των καναλιών χρησιμοποίησα λίστα την οποία υλοποιώ στο list.h . Ο κάθε κόμβος της λίστας αυτής αποτελέι και ένα κανάλι το
οποίο με τη σειρά του αποτελείται από το όνομά του, το ID του, τη λίστα με τα μηνήματα (string) και τη λίστα με τα αρχεία. Μου φάνηκε απλούστερη η
υλοποίηση που έκανα στην οποία όταν σταλεί ένα αρχείο αυτό αποθηκεύεται στο δίσκο στο φάκελο του board και το όνομά του αποθηκεύεται στη δομή των
καναλιών στη λίστα με τα αρχεία. Όταν ζητηθεί μέσω της getmessages, στέλνεται μέσω του fifo και αποθηκεύεται στο φάκελο από τον οποίο καλέστηκε η board
και ακολούθως διαφράφεται από το φάκελο board που είχε αποθηκευθεί προσωρινά. Μετά από κάθε getmessages η λίστα μηνυμάτων όπως και η λίστα αρχείων του
καναλιού αδειάζει.
